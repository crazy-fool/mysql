一、索引的本质
------
 - MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的数据结构**。
 - 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
二、索引类型
------

 - 索引的类型 - 按照维护与管理索引角度分为
 ![](http://a2.qpic.cn/psb?/V14EGSbs4eQiTA/FTEZvvjInZQCAqitkc1y4fFVSPS*biFSn3Q6CjfWGBk!/b/dP0AAAAAAAAA&bo=6gIKAuoCCgIDCSw!&rf=viewer_4)

 
1. 普通索引
普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件(WHERE column = …)或排序条件(ORDER BY column)中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列(如一个整数类型的数据列)来创建索引。
> 创建索引，例如create index index_name ON table_name (col1);
> 增加索引，例如alter table table_name add index index_name(col1); 
> 创建表的时候指定索引，例如create table table_name ( [...], INDEX 索引的名字 (col1.) );
> 删除索引，例如alter table table_name drop index index_name;

2. 唯一索引
普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。
如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。
> 创建索引，例如create unique index index_name on table_name (col1);  
> 增加索引，例如alert table table_name add unique index_name (col1);  
> 创建表的时候指定索引，例如create table table_name ( [...], unique index_name (col1) );

3. 主键索引
主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是 PRIMARY而不是UNIQUE。
4. 单列索引和多列索引（复合索引） 
单列索引就是常用的一个列字段的索引，常见的索引。 
多列索引就是含有多个列字段的索引，对于多列索引:Mysql会从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。
> 修改表 alter table table_name add index_name(col1,col2,col3)。

5. 全文索引
文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成 的较大段文字，普通索引就没什么作用了。这种检索往往以LIKE %word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。
这类场合正是全文索引(full-text index)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数 据记录。全文索引即可以随数据表一同创建。
注解：InnoDB引擎在MySQL5.6及以上版本才支持全文索引。
> 修改表 ALTER TABLE tablename ADD FULLTEXT(column1, column2)


 - 按照存储方式分为：聚集索引、非聚集索引
 
 1. 聚簇索引
InnoDb的聚簇索引实际上是在同一个结构中保存了B-Tree索引和数据行。 
当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。“聚簇”就是索引和记录紧密在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。
下图展示了聚簇索引中的记录是如何存放的。叶子页包含行的全部数据，但是节点页只包含了索引列。
![](http://a2.qpic.cn/psb?/V14EGSbs4eQiTA/yuu4M4BQ410qfiMQnwmdACwNJ3iE4NGNVsRQFdJTWV8!/b/dPoAAAAAAAAA&bo=*gUgBP4FIAQDACU!&rf=viewer_4)
[拓展链接1](http://www.th7.cn/db/mysql/201409/70794.shtml) [拓展链接2](http://www.admin10000.com/document/5372.html) [拓展链接3](http://my.oschina.net/xinxingegeya/blog/495308)

2. 非聚簇索引
索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块。

3. 聚簇索引与非聚簇索引对比
InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。
MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。
为了更形象说明这两种索引的区别，我们假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。
注：每个InnoDB引擎的表都有一个聚簇索引，除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。
![](http://a3.qpic.cn/psb?/V14EGSbs4eQiTA/SxzNptKCUsV7D0zzhI*KbdxKZnbPd3sZcZhsQZ1giA0!/b/dKoAAAAAAAAA&bo=qgQ4BBYFmgQDADo!&rf=viewer_4)



三、索引的存储结构
-------
- b-tree
当人们在谈论索引的时候，如果没有指定类型，那么多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。（InnoDB使用的是B+Tree） 关于B-树 和 B+ 见：http://my.oschina.net/xinxingegeya/blog/472668
B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。
      ![](http://a1.qpic.cn/psb?/V14EGSbs4eQiTA/lpxA5e5l5jaTFyftYAb9sWg2fpmW8RlSO4zE7HxBRtE!/b/dKIAAAAAAAAA&bo=.gOaAfoDmgEDACU!&rf=viewer_4)

- hash
哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希吗（hash code），哈希吗是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
在MySQL中，只有Memory引擎显式支持哈希索引。
InnoDB引擎有一个特殊的功能叫做“自适应哈希”，当InnodeDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上在创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。
- 空间数据索引（R-Tree）
MyISAM表支持空间索引，可以用做地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用mysql的GIS相关函数如MBRCONTAINS()等来维护数据。mysql的GIS支持并不完善，所以大部分人都不会使用这个特性。开源数据库中对GIS的解决方案做的比较好的是PostgreSQL的postGIS。

- 全文索引（FULL TEXT INDEX）
全文索引是一种特殊类型的索引，他查找的是文本中的关键词，而不是直接比较索引中的值。全文索引和其他几类索引的匹配方式完全不一样。他有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似与搜索引擎做的事情，而不是简单的where条件匹配。
在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的where条件操作。

三、高性能的索引策略
----------

 - 独立的列作为索引
 如果查询中的列不是独立的，则mysql就不会使用索引，独立的列是指列不能是表达式的一部分，也不能是函数的参数。
 不是独立的列 例：explain select * from campaign_info where id +1 = 2;
 独立的列         例：explain select * from campaign_info where id = 2;
 
 - 使用字段选择性高的的字段来建立索引
  show index from table 查看表上的索引。
 <table>
<tr>
<th>Table</th>
<td>表的名称</td>
</tr>
<tr>
<th>Non_unique</th>
<td>如果索引不能包括重复词，则为0。如果可以，则为1。</td>
</tr>
<tr>
<th>Key_name</th>
<td>索引的名称。</td>
</tr>
<tr>
<th>Seq_in_index</th>
<td>索引中的列序列号，从1开始</td>
</tr>
<tr>
<th>Column_name</th>
<td>列名称。</td>
</tr>
<tr>
<th>Collation</th>
<td>列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。
</td>
</tr>
<tr>
<th>Cardinality</th>
<td>索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大</td>
</tr>
<tr>
<th>Sub_part</th>
<td>如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</td>
</tr>
<tr>
<th>Packed</th>
<td>指示关键字如何被压缩。如果没有被压缩，则为NULL。</td>
</tr>
<tr>
<th>Null</th>
<td>如果列含有NULL，则含有YES。如果没有，则该列含有NO。
</td>
</tr>
<tr>
<th>Index_type</th>
<td>用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</td>
</tr>
</tbody>
</table>
索引选择性=索引列唯一值/表记录数；
选择性较低索引 可能带来的性能问题
选择性越高索引检索价值越高，消耗系统资源越少；选择性越低索引检索价值越低，消耗系统资源越多；
查询条件含有多个字段时，不要在选择性很低字段上创建索引
可通过创建组合索引来增强低字段选择性和避免选择性很低字段创建索引带来副作用；
尽量减少possible_keys，正确索引会提高sql查询速度，过多索引会增加优化器选择索引的代价，不要滥用索引；

 - 选择合适的索引列顺序
在一个多列的B－Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY ,GROUP BY和DISTINCT等子句的查询要求。
对于如何选择索引的列的顺序有一个经验法则：将选择性最高的列放到索引最前列。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找，可以最快的过滤出需要的数据行。但有时我们需要根据那些运行频率最高的查询来调整索引列的顺序。
计算出列的选择性：
select count(distinct twitter_id)/count(*) as twitter_count , count(distinct aid)/count(*) as aid_count from campaign_goods_info; 
 
 - 使用覆盖索引
如果索引包含满足查询的所有数据，就称为覆盖索引。覆盖索引是一种非常强大的工具，能大大提高查询性能。只需要读取索引而不用读取数据有以下一些优点：
(1)索引项通常比记录要小，所以MySQL访问更少的数据；
(2)索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O；
(3)大多数据引擎能更好的缓存索引。比如MyISAM只缓存索引。
(4)覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。
覆盖索引不能是任何索引，只有B-TREE索引存储相应的值。而且不同的存储引擎实现覆盖索引的方式都不同，并不是所有存储引擎都支持覆盖索引(Memory就不支持)。
例：explain select aid, goods_id from campaign_goods_info;

四、索引优化案例
------
 ##- 优化LIMIT分页
在系统中需要进行分页操作的时候，我们通常会用LIMIT加上偏移量的方法来实现，同时加上合适的ORDER BY子句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。
例如可能是LIMIT 1000,20这样的查询，这是MySQL需要扫描10020条记录然后只返回最后20条，前面的10000条记录都将被抛弃，这样做的代价非常高。
###优化方法一：
尽可能的使用覆盖索引，而不是查询所有的列。
###优化方法二：
LIMIT和OFFSET的问题，其实就是OFFSET的问题，它会导致M有SQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。
该技术的好处是，无论翻页到多么后面，其性能都会很好！